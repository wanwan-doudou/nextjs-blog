---
title: JUC概述
date: 2022-01-29 00:00:00
tags:
  - 并发编程
---

# 1 什么是JUC

## [](https://kwydy.gitee.io/2022/01/29/JUC%E6%A6%82%E8%BF%B0/#1-1-JUC%E7%AE%80%E4%BB%8B "1.1 JUC简介")1.1 JUC简介

在Java中，线程部分是一个重点，本篇文章说的JUC也是关于线程的。JUC就是java.util .concurrent工具包的简称。这是一个处理线程的工具包，JDK1.5开始出现的。

## [](https://kwydy.gitee.io/2022/01/29/JUC%E6%A6%82%E8%BF%B0/#1-2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B "1.2 进程和线程")1.2 进程和线程

**进程(Process** )是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。,

**线程( thread）**是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

总结来说:  
进程∶指在系统中正在运行的一个应用程序﹔程序一旦运行就是进程﹔进程——资源分配的最小单位。  
线程︰系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。

## [](https://kwydy.gitee.io/2022/01/29/JUC%E6%A6%82%E8%BF%B0/#1-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81 "1.3 线程的状态")1.3 线程的状态

### [](https://kwydy.gitee.io/2022/01/29/JUC%E6%A6%82%E8%BF%B0/#1-3-1-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E6%9E%9A%E4%B8%BE "1.3.1 线程状态枚举")1.3.1 线程状态枚举

**Thread.State**
    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    

| 
    
    
    public enum State {    
    /**    
     * Thread state for a thread which has not yet started.    
     */    
    NEW,(新建}    
    RUNNABLE,(准备就绪)    
    BLOCKED,(阻塞)    
    WAITING,(不见不散)    
    TIMED_WAITING,(过时不候)    
    TERMINATED;(终结)    
    }  
      
  
---|---  
  
### 1.3.2 wait / sleep 的区别

( 1 ) sleep是Thread 的静态方法，wait是 Object的方法，任何对象实例都能调用。

( 2 ) sleep不会释放锁，它也不需要占用锁。wait 会释放锁，但调用它的前提是当前线程占有锁(即代码要在synchronized 中)。

( 3 )它们都可以被interrupted方法中断。

## [](https://kwydy.gitee.io/2022/01/29/JUC%E6%A6%82%E8%BF%B0/#1-4-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C "1.4 并发与并行")1.4 并发与并行

### [](https://kwydy.gitee.io/2022/01/29/JUC%E6%A6%82%E8%BF%B0/#1-4-1-%E4%B8%B2%E8%A1%8C%E6%A8%A1%E5%BC%8F "1.4.1 串行模式")1.4.1 串行模式

串行表示所有任务都——按先后顺序进行。串行意味着必须先装完一车柴才能运送这车柴，只有运送到了，才能卸下这车柴，并且只有完成了这整个三个步骤，才能进行下一个步骤。

**串行是一次只能取得一个任务，并执行这个任务。**

### [](https://kwydy.gitee.io/2022/01/29/JUC%E6%A6%82%E8%BF%B0/#1-4-2-%E5%B9%B6%E8%A1%8C%E6%A8%A1%E5%BC%8F "1.4.2 并行模式")1.4.2 并行模式

并行意味着可以同时取得多个任务，并同时去执行所取得的这些任务。并行模式相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列的长度。并行的效率从代码层次上强依赖于多进程/多线程代码，从硬件角度上则依赖于多核CPU。

### [](https://kwydy.gitee.io/2022/01/29/JUC%E6%A6%82%E8%BF%B0/#1-4-3-%E5%B9%B6%E5%8F%91 "1.4.3 并发")1.4.3 并发

**并发(concurrent)指的是多个程序可以同时运行的现象，更细化的是多进程可以同时运行或者多指令可以同时运行** 。但这不是重点，在描述并发的时候也不会去扣这种字眼是否精确，==并发的重点在于它是一种现象==，==并发描述的是多进程同时运行的现象==。但实际上，对于单核心CPU来说，同一时刻只能运行一个线程。所以，这里的”同时运行”表示的不是真的同一时刻有多个线程运行的现象，这是并行的概念，而是提供一种功能让用户看来多个程序同时运行起来了，但实际上这些程序中的进程不是一直霸占CPU的，而是执行一会停一会。

**要解决大并发问题，通常是将大任务分解成多个小任务，**由于操作系统对进程的调度是随机的，所以切分成多个小任务后，可能会从任一小任务处执行。这可能会出现一些现象︰

  * 可能出现一个小任务执行了多次，还没开始下个任务的情况。这时一般会采用队列或类似的数据结构来存放各个小任务的成果
  * 可能出现还没准备好第一步就执行第二步的可能。这时，一般采用多路复用或异步的方式，比如只有准备好产生了事件通知才执行某个任务。
  * 可以多进程/多线程的方式并行执行这些小任务。也可以单进程/单线程执行这些小任务，这时很可能要配合多路复用才能达到较高的效率



### [](https://kwydy.gitee.io/2022/01/29/JUC%E6%A6%82%E8%BF%B0/#1-4-4-%E5%B0%8F%E7%BB%93%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89 "1.4.4 小结（重点）")1.4.4 小结（重点）

**并发：**同一时刻多个线程在访问同一个资源，多个线程对一个点

​ 例子∶春运抢票电商秒杀.….

**并行:** 多项工作一起执行，之后再汇总:

​ 例子︰泡方便面，电水壶烧水，一边撕调料倒入桶中

## [](https://kwydy.gitee.io/2022/01/29/JUC%E6%A6%82%E8%BF%B0/#1-5-%E7%AE%A1%E7%A8%8B-Monitor%EF%BC%88%E7%9B%91%E8%A7%86%E5%99%A8%EF%BC%89 "1.5 管程 Monitor（监视器）")1.5 管程 Monitor（监视器）

保证同一时间，只有一个线程

## [](https://kwydy.gitee.io/2022/01/29/JUC%E6%A6%82%E8%BF%B0/#1-6-%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B "1.6 用户线程和守护线程")1.6 用户线程和守护线程

用户线程：自定义线程

主线程结束了，用户线程还在运行，jvm存活
    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    

| 
    
    
    public class Main {    
        public static void main(String[] args) {    
            Thread aa = new Thread(() -> {    
                System.out.println(Thread.currentThread().getName() + "::" + Thread.currentThread().isDaemon());    
                while (true) {    
        
                }    
            }, "aa");    
            aa.start();    
        
            System.out.println(Thread.currentThread().getName()+"over");    
        }    
    }  
      
  
---|---  
      
    
    1  
    2  
    3  
    

| 
    
    
    // 输出结果    
    main over    
    aa::false  
      
  
---|---  
  
守护线程：比如垃圾回收

没有用户线程了，都是守护线程，jvm结束
    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    

| 
    
    
    public class Main {    
        public static void main(String[] args) {    
            Thread aa = new Thread(() -> {    
                System.out.println(Thread.currentThread().getName() + "::" + Thread.currentThread().isDaemon());    
                while (true) {    
        
                }    
            }, "aa");    
            // 设置守护线程    
            aa.setDaemon(true);    
    		aa.start();    
            System.out.println(Thread.currentThread().getName()+"over");    
        }    
    }  
      
  
---|---  
      
    
    1  
    2  
    3  
    

| 
    
    
    // 输出结果    
    main over    
    aa::true  
      
  
---|---  
  
主线程退出后，守护线程依然在运行！由此得到只要任何非守护线程还在运行，守护线程就不会终止
