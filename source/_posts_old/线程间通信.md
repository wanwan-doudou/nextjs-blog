---
title: 线程间通信
date: 2022-01-30 00:00:00
tags:
  - 并发编程
---

## 线程间通信的几种实现方式

**题目：有多个个线程分别对int number操作，一共操作十次，当number等于0时number加一，当number等于1时number减一** 。

#### [](https://kwydy.gitee.io/2022/01/30/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8Object%E7%B1%BB%E7%9A%84wait-%E5%92%8C-notifyAll-%E6%96%B9%E6%B3%95 "方式一：使用Object类的wait\(\) 和 notifyAll\(\) 方法")方式一：使用Object类的wait() 和 notifyAll() 方法
    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    33  
    34  
    35  
    36  
    37  
    38  
    39  
    40  
    41  
    42  
    43  
    44  
    45  
    46  
    47  
    48  
    49  
    50  
    51  
    52  
    53  
    54  
    55  
    56  
    57  
    58  
    59  
    60  
    61  
    62  
    63  
    64  
    

| 
    
    
    class Share {    
        /**    
         * 初始值    
         */    
        private int number = 0;    
        
        /**    
         * +1的方法    
         */    
        public synchronized void incr() throws InterruptedException {    
            // 第二部 判断 干活 通知    
            // 判断number值是否是0，如果不是0，等待    
            if (number != 0) {    
                this.wait();    
            }    
            // 弱国number值是0，就+1操作    
            number++;    
            System.out.println(Thread.currentThread().getName() + " :: " + number);    
            // 通知其他线程    
            this.notifyAll();    
        }    
        
        /**    
         * 减一的方法    
         */    
        public synchronized void decr() throws InterruptedException {    
            // 判断    
            if (number != 1) {    
                this.wait();    
            }    
            // 干活    
            number--;    
            System.out.println(Thread.currentThread().getName() + " :: " + number);    
            this.notifyAll();    
        }    
    }    
        
    /**    
     * @author myAnswer <2273024587@qq.com>    
     * @since 2022/1/30 20:12    
     */    
    public class ThreadDemo1 {    
        public static void main(String[] args) {    
            Share share = new Share();    
            new Thread(() -> {    
                for (int i = 1; i <= 10; i++) {    
                    try {    
                        share.incr();    
                    } catch (InterruptedException e) {    
                        e.printStackTrace();    
                    }    
                }    
            }, "AA").start();    
            new Thread(() -> {    
                for (int i = 1; i <= 10; i++) {    
                    try {    
                        share.decr();     
                    } catch (InterruptedException e) {    
                        e.printStackTrace();    
                    }    
                }    
            }, "BB").start();    
        }    
    }  
      
  
---|---  
  
输出：

[![](https://kwydy.oss-cn-guangzhou.aliyuncs.com/blog/image-20220130204411664.png)](https://kwydy.oss-cn-guangzhou.aliyuncs.com/blog/image-20220130204411664.png)

### [](https://kwydy.gitee.io/2022/01/30/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/#%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E9%97%AE%E9%A2%98 "虚假唤醒问题")虚假唤醒问题

这里我们创建4个线程发别执行加减的方法
    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    33  
    34  
    35  
    36  
    37  
    38  
    39  
    40  
    41  
    

| 
    
    
    public class ThreadDemo1 {    
        public static void main(String[] args) {    
            Share share = new Share();    
            new Thread(() -> {    
                for (int i = 1; i <= 10; i++) {    
                    try {    
                        share.incr();    
                    } catch (InterruptedException e) {    
                        e.printStackTrace();    
                    }    
                }    
            }, "AA").start();    
            new Thread(() -> {    
                for (int i = 1; i <= 10; i++) {    
                    try {    
                        share.decr();    
                    } catch (InterruptedException e) {    
                        e.printStackTrace();    
                    }    
                }    
            }, "BB").start();    
            new Thread(() -> {    
                for (int i = 1; i <= 10; i++) {    
                    try {    
                        share.incr();    
                    } catch (InterruptedException e) {    
                        e.printStackTrace();    
                    }    
                }    
            }, "CC").start();    
            new Thread(() -> {    
                for (int i = 1; i <= 10; i++) {    
                    try {    
                        share.decr();    
                    } catch (InterruptedException e) {    
                        e.printStackTrace();    
                    }    
                }    
            }, "DD").start();    
        }    
    }  
      
  
---|---  
  
可以看到结果和预期不一致

[![](https://kwydy.oss-cn-guangzhou.aliyuncs.com/blog/image-20220130204318616.png)](https://kwydy.oss-cn-guangzhou.aliyuncs.com/blog/image-20220130204318616.png)

解决方法：使用while判断，线程被唤醒时还要经过判断才往下走
    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    

| 
    
    
    public synchronized void incr() throws InterruptedException {    
        // 第二部 判断 干活 通知    
        // 判断number值是否是0，如果不是0，等待    
        while (number != 0) {    
            this.wait();    
        }    
        // 如果number值是0，就+1操作    
        number++;    
        System.out.println(Thread.currentThread().getName() + " :: " + number);    
        // 通知其他线程    
        this.notifyAll();    
    }  
      
  
---|---  
  
### 方式二：使用 ReentrantLock
    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    33  
    34  
    35  
    36  
    37  
    38  
    39  
    40  
    41  
    42  
    43  
    44  
    45  
    46  
    47  
    48  
    49  
    50  
    51  
    52  
    53  
    54  
    55  
    56  
    57  
    58  
    59  
    60  
    61  
    62  
    63  
    64  
    65  
    66  
    67  
    68  
    69  
    70  
    71  
    72  
    73  
    74  
    75  
    76  
    77  
    78  
    79  
    80  
    81  
    82  
    83  
    84  
    85  
    86  
    87  
    88  
    89  
    90  
    91  
    92  
    93  
    94  
    95  
    96  
    97  
    98  
    99  
    

| 
    
    
    class Share {    
        private int number = 0;    
        
        /**    
         * 创建Lock    
         */    
        private Lock lock = new ReentrantLock();    
        private Condition condition = lock.newCondition();    
        
        /**    
         * +1    
         */    
        public void incr() throws InterruptedException {    
            // 上锁    
            lock.lock();    
            try {    
                // 判断    
                while (number != 0) {    
                    condition.await();    
                }    
                // 干活    
                number++;    
                System.out.println(Thread.currentThread().getName() + " :: " + number);    
                // 通知    
                condition.signalAll();    
            } finally {    
                // 解锁    
                lock.unlock();    
            }    
        }    
        
        /**    
         * 1-    
         */    
        public void decr() throws InterruptedException {    
            // 上锁    
            lock.lock();    
            try {    
                // 判断    
                while (number != 1) {    
                    condition.await();    
                }    
                // 干活    
                number--;    
                System.out.println(Thread.currentThread().getName() + " :: " + number);    
                // 通知    
                condition.signalAll();    
            } finally {    
                // 解锁    
                lock.unlock();    
            }    
        }    
    }    
        
    /**    
     * @author myAnswer <2273024587@qq.com>    
     * @since 2022/1/30 20:55    
     */    
    public class ThreadDemo2 {    
        public static void main(String[] args) {    
            Share share = new Share();    
            new Thread(() -> {    
                for (int i = 1; i <= 10; i++) {    
                    try {    
                        share.incr();    
                    } catch (InterruptedException e) {    
                        e.printStackTrace();    
                    }    
                }    
            }, "AA").start();    
            new Thread(() -> {    
                for (int i = 1; i <= 10; i++) {    
                    try {    
                        share.decr();    
                    } catch (InterruptedException e) {    
                        e.printStackTrace();    
                    }    
                }    
            }, "BB").start();    
            new Thread(() -> {    
                for (int i = 1; i <= 10; i++) {    
                    try {    
                        share.incr();    
                    } catch (InterruptedException e) {    
                        e.printStackTrace();    
                    }    
                }    
            }, "CC").start();    
            new Thread(() -> {    
                for (int i = 1; i <= 10; i++) {    
                    try {    
                        share.decr();    
                    } catch (InterruptedException e) {    
                        e.printStackTrace();    
                    }    
                }    
            }, "DD").start();    
        }    
    }  
      
  
---|---  
  
运行结果为：

[![](https://kwydy.oss-cn-guangzhou.aliyuncs.com/blog/image-20220130212718351.png)](https://kwydy.oss-cn-guangzhou.aliyuncs.com/blog/image-20220130212718351.png)

## [](https://kwydy.gitee.io/2022/01/30/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/#%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%AE%9A%E5%88%B6%E5%8C%96%E9%80%9A%E4%BF%A1 "线程间定制化通信")线程间定制化通信

synchronized实现线程间通信的案例如果有多个线程那么就无法指定线程执行的顺序，我们可以使用Lock锁的Condition 实现线程定制化通信

实例：  
A线程打印2次A，B线程打印3次B，C线程打印5次C,按照此顺序循环10轮

思路：创建三个线程给每个线程设置一个标志位

线程A判断flag=0，打印2次，修改flag=1,通知线程B

线程B判断flag=1，打印3次，修改flag=2,通知线程C

线程C判断flag=2，打印5次，修改flag=0,通知线程A
    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    33  
    34  
    35  
    36  
    37  
    38  
    39  
    40  
    41  
    42  
    43  
    44  
    45  
    46  
    47  
    48  
    49  
    50  
    51  
    52  
    53  
    54  
    55  
    56  
    57  
    58  
    59  
    60  
    61  
    62  
    63  
    64  
    65  
    66  
    67  
    68  
    69  
    70  
    71  
    72  
    73  
    74  
    75  
    76  
    77  
    78  
    79  
    80  
    81  
    82  
    83  
    84  
    85  
    86  
    87  
    88  
    89  
    90  
    91  
    92  
    93  
    94  
    95  
    96  
    97  
    98  
    99  
    100  
    101  
    102  
    103  
    104  
    105  
    106  
    107  
    108  
    109  
    110  
    111  
    112  
    113  
    114  
    115  
    116  
    117  
    118  
    119  
    120  
    121  
    122  
    123  
    124  
    125  
    126  
    127  
    128  
    129  
    130  
    131  
    132  
    133  
    134  
    135  
    136  
    137  
    138  
    139  
    140  
    

| 
    
    
    /**    
     * 第一步 创建资源类    
     */    
    class ShareResource {    
        /**    
         * 定义标志位    
         * 1 AA    
         * 2 BB    
         * 3 CC    
         */    
        private int flag = 1;    
        /**    
         * 创建Lock锁    
         */    
        private Lock lock = new ReentrantLock();    
        /**    
         * 创建三个condition    
         */    
        private Condition c1 = lock.newCondition();    
        private Condition c2 = lock.newCondition();    
        private Condition c3 = lock.newCondition();    
        
        /**    
         * @param loop 轮数    
         * @throws InterruptedException    
         */    
        public void print5(int loop) throws InterruptedException {    
            // 上锁    
            lock.lock();    
            try {    
                // 判断    
                while (flag != 1) {    
                    // 等待    
                    c1.await();    
                }    
                // 干活    
                for (int i = 1; i <= 5; i++) {    
                    System.out.println(Thread.currentThread().getName() + " :: " + i + " :轮数" + loop);    
                }    
                // 通知    
                // 修改标志位2    
                flag = 2;    
                // 通知BB线程    
                c2.signal();    
            } finally {    
                lock.unlock();    
            }    
        }    
        
        /**    
         * @param loop 轮数    
         * @throws InterruptedException    
         */    
        public void print10(int loop) throws InterruptedException {    
            // 上锁    
            lock.lock();    
            try {    
                // 判断    
                while (flag != 2) {    
                    // 等待    
                    c2.await();    
                }    
                // 干活    
                for (int i = 1; i <= 10; i++) {    
                    System.out.println(Thread.currentThread().getName() + " :: " + i + " :轮数" + loop);    
                }    
                // 通知    
                // 修改标志位2    
                flag = 3;    
                // 通知BB线程    
                c3.signal();    
            } finally {    
                lock.unlock();    
            }    
        }    
        
        /**    
         * @param loop 轮数    
         * @throws InterruptedException    
         */    
        public void print15(int loop) throws InterruptedException {    
            // 上锁    
            lock.lock();    
            try {    
                // 判断    
                while (flag != 3) {    
                    // 等待    
                    c3.await();    
                }    
                // 干活    
                for (int i = 1; i <= 15; i++) {    
                    System.out.println(Thread.currentThread().getName() + " :: " + i + " :轮数" + loop);    
                }    
                // 通知    
                // 修改标志位2    
                flag = 1;    
                // 通知BB线程    
                c1.signal();    
            } finally {    
                lock.unlock();    
            }    
        }    
    }    
        
    /**    
     * @author myAnswer <2273024587@qq.com>    
     * @since 2022/1/30 21:50    
     */    
    public class ThreadDemo3 {    
        public static void main(String[] args) {    
            ShareResource shareResource = new ShareResource();    
            new Thread(() -> {    
                for (int i = 1; i <= 10; i++) {    
                    try {    
                        shareResource.print5(i);    
                    } catch (InterruptedException e) {    
                        e.printStackTrace();    
                    }    
                }    
            }, "AA").start();    
            new Thread(() -> {    
                for (int i = 1; i <= 10; i++) {    
                    try {    
                        shareResource.print10(i);    
                    } catch (InterruptedException e) {    
                        e.printStackTrace();    
                    }    
                }    
            }, "BB").start();    
            new Thread(() -> {    
                for (int i = 1; i <= 15; i++) {    
                    try {    
                        shareResource.print15(i);    
                    } catch (InterruptedException e) {    
                        e.printStackTrace();    
                    }    
                }    
            }, "CC").start();    
        }    
    }  
      
  
---|---  
  
输出结果为：

[![](https://kwydy.oss-cn-guangzhou.aliyuncs.com/blog/image-20220130221959831.png)](https://kwydy.oss-cn-guangzhou.aliyuncs.com/blog/image-20220130221959831.png)
